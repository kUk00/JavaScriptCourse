//Прототипное наследование
//Например, у нас есть объект user со своими свойствами и методами,
// и мы хотим создать объекты admin и guest как его слегка изменённые варианты. 
//Мы хотели бы повторно использовать то, что есть у объекта user,
// не копировать/переопределять его методы, а просто создать новый объект на его основе.

let animal = {
    eats: true
  };
  let rabbit = {
    jumps: true
  };
  
  rabbit.__proto__ = animal; // (*)
  
  // теперь мы можем найти оба свойства в rabbit:
  alert( rabbit.eats ); // true (**)
  alert( rabbit.jumps ); // true
  // когда alert пытается прочитать свойство rabbit.eats (**), его нет в rabbit, поэтому JavaScript следует по ссылке [[Prototype]] и находит его в animal

  let animal2 = {
    eats: true,
    walk() {
      alert("Animal2 walk");
    }
  };
  
  let rabbit2 = {
    jumps: true,
    __proto__: animal
  };
  
  // walk взят из прототипа
  rabbit2.walk(); // Animal2 walk


  /*
  Итого
В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).
Объект, на который ссылается [[Prototype]], называется «прототипом».
Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.
*/